<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.miek.nl" -->
<rfc version="3" ipr="none" docName="fapi-security-profile-2_0-04" submissionType="IETF" category="std" xml:lang="en" xmlns:xi="http://www.w3.org/2001/XInclude" indexInclude="true" consensus="true">

<front>
<title abbrev="fapi-security-profile-2">FAPI 2.0 Security Profile — Draft 04</title><seriesInfo value="fapi-security-profile-2_0-04" status="standard" name="Internet-Draft"></seriesInfo>
<author initials="D." surname="Fett" fullname="Daniel Fett"><organization>Authlete</organization><address><postal><street></street>
</postal><email>mail@danielfett.de</email>
</address></author><author initials="D." surname="Tonge" fullname="Dave Tonge"><organization>Moneyhub Financial Technology</organization><address><postal><street></street>
</postal><email>dave@tonge.org</email>
</address></author><author initials="J." surname="Heenan" fullname="Joseph Heenan"><organization>Authlete</organization><address><postal><street></street>
</postal><email>joseph@authlete.com</email>
</address></author><date/>
<area>Internet</area>
<workgroup>fapi</workgroup>
<keyword>security</keyword>
<keyword>openid</keyword>

<abstract>
<t>OIDF FAPI 2.0 is an API security profile suitable for high-security
applications based on the OAuth 2.0 Authorization Framework
<xref target="RFC6749"></xref>.</t>
</abstract>

<note><name>Foreword</name>
<t>The OpenID Foundation (OIDF) promotes, protects and nurtures the OpenID community and technologies. As a non-profit international standardizing body, it is comprised by over 160 participating entities (workgroup participant). The work of preparing implementer drafts and final international standards is carried out through OIDF workgroups in accordance with the OpenID Process. Participants interested in a subject for which a workgroup has been established have the right to be represented in that workgroup. International organizations, governmental and non-governmental, in liaison with OIDF, also take part in the work. OIDF collaborates closely with other standardizing bodies in the related fields.</t>
<t>Final drafts adopted by the Workgroup through consensus are circulated publicly for the public review for 60 days and for the OIDF members for voting. Publication as an OIDF Standard requires approval by at least 50% of the members casting a vote. There is a possibility that some of the elements of this document may be subject to patent rights. OIDF shall not be held responsible for identifying any or all such patent rights.</t>
</note>

<note><name>Introduction</name>
<t>The FAPI 2.0 Security Profile is an API security profile based on the
OAuth 2.0 Authorization Framework <xref target="RFC6749"></xref> and related specifications
that aims to reach the security goals laid out in the Attacker
Model <xref target="attackermodel"></xref> so that it is suitable for
protecting APIs in high-value scenarios. It also follows the recommendations
in the OAuth Security BCP <xref target="I-D.ietf-oauth-security-topics"></xref>.</t>
<t>This document specifies the process for a client to obtain sender-constrained
tokens from an authorization server and use them securely with resource servers.</t>
<t>The OpenID Foundation FAPI Working Group publishes additional documents that build on this
profile as part of the FAPI 2.0 framework.</t>
<t>The security property is formally analysed <xref target="FAPI2SEC"></xref> under the aforementioned attacker model.
For the security assumptions, please refer the attacker model.</t>
<t>While the security profile was initially developed with a focus on financial applications,
it is designed to be universally applicable for protecting APIs exposing high-value
and sensitive (personal and other) data, for example, in e-health and e-government
applications.</t>
</note>

<note><name>Warning</name>
<t>This document is not an OIDF International Standard. It is distributed for
review and comment. It is subject to change without notice and may not be
referred to as an International Standard.</t>
<t>Recipients of this draft are invited to submit, with their comments,
notification of any relevant patent rights of which they are aware and to
provide supporting documentation.</t>
</note>

<note><name>Notational conventions</name>
<t>The keywords &quot;shall&quot;, &quot;shall not&quot;, &quot;should&quot;, &quot;should not&quot;, &quot;may&quot;, and &quot;can&quot; in
this document are to be interpreted as described in ISO Directive Part 2
<xref target="ISODIR2"></xref>. These keywords are not used as dictionary terms such that any
occurrence of them shall be interpreted as keywords and are not to be
interpreted with their natural language meanings.</t>
</note>

</front>

<middle>

<section anchor="scope"><name>Scope</name>
<t>This document provides a general-purpose high security profile of
OAuth 2.0 that has been proved by formal analysis to meet the stated
attacker model. This document specifies the requirements for:</t>

<ul spacing="compact">
<li>Confidential clients to securely obtain OAuth tokens from authorization servers;</li>
<li>Confidential clients to securely use those tokens to access protected resources at resource servers;</li>
<li>Authorization servers to securely issue OAuth tokens to confidential clients;</li>
<li>Resource servers to securely accept and verify OAuth tokens from confidential clients.</li>
</ul>
</section>

<section anchor="normative-references"><name>Normative references</name>
<t>The following documents are referred to in the text in such a way that some or all of their content constitutes requirements of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</t>
<t>See Section 10 for normative references.</t>
</section>

<section anchor="terms-and-definitions"><name>Terms and definitions</name>
<t>For the purpose of this document, the terms defined in <xref target="RFC6749"></xref>, <xref target="RFC6750"></xref>, <xref target="RFC7636"></xref>, <xref target="OIDC"></xref> and <xref target="ISO29100"></xref> apply.</t>
</section>

<section anchor="symbols-and-abbreviated-terms"><name>Symbols and Abbreviated terms</name>
<t><strong>API</strong> – Application Programming Interface</t>
<t><strong>BCM</strong> – Basin, Cremers, Meier</t>
<t><strong>BCP</strong> – Best Current Practice</t>
<t><strong>CAA</strong> – Certificate Authority Authorization</t>
<t><strong>CIBA</strong> – Client Initiated Backchannel Authentication</t>
<t><strong>CSRF</strong> –  Cross-Site Request Forgery</t>
<t><strong>DNS</strong> – Domain Name System</t>
<t><strong>DNSSEC</strong> –  Domain Name System Security Extensions</t>
<t><strong>HTTP</strong> – Hyper Text Transfer Protocol</t>
<t><strong>JAR</strong> – JWT-Secured Authorization Request</t>
<t><strong>JARM</strong> – JWT Secured Authorization Response Mode</t>
<t><strong>JWK</strong> – JSON Web Key</t>
<t><strong>JWKS</strong> – JSON Web Key Sets</t>
<t><strong>JWT</strong> – JSON Web Token</t>
<t><strong>JOSE</strong> – Javascript Object Signing and Encryption</t>
<t><strong>JSON</strong> – JavaScript Object Notation</t>
<t><strong>MTLS</strong> – Mutual Transport Layer Security</t>
<t><strong>OIDF</strong> – OpenID Foundation</t>
<t><strong>PAR</strong> – Pushed Authorization Requests</t>
<t><strong>PKCE</strong> – Proof Key for Code Exchange</t>
<t><strong>QR</strong> – Quick Response</t>
<t><strong>RSA</strong> – Rivest-Shamir-Adleman</t>
<t><strong>REST</strong> – Representational State Transfer</t>
<t><strong>TLS</strong> – Transport Layer Security</t>
<t><strong>URI</strong> – Uniform Resource Identifier</t>
<t><strong>URL</strong> – Uniform Resource Locator</t>
</section>

<section anchor="security-profile"><name>Security profile</name>

<section anchor="overview"><name>Overview</name>

<section anchor="introduction-1"><name>Introduction</name>
<t>The FAPI 2.0 Security Profile is an API security profile based on the OAuth 2.0 Authorization
Framework <xref target="RFC6749"></xref>, that aims:
 - to reach the security goals laid out in the Attacker Model <xref target="attackermodel"></xref>; and
 - to follow the recommendations in the OAuth Security BCP <xref target="I-D.ietf-oauth-security-topics"></xref>.</t>
<t>The OpenID FAPI Working Group is not currently aware of any mechanisms that would allow
public clients to be secured to the same degree and hence their use is not within the scope
of this document.</t>
<t>Although it is possible to code authorization servers and clients from first
principles using this document, implementers are encouraged to build on top
of existing OpenID Connect and/or OAuth 2.0 implementations instead of embarking
on a 'from scratch' implementation. See
<xref target="incomplete-or-incorrect-implementations-of-the-specifications"></xref> for additional
considerations for ensuring that implementations are complete and correct.</t>
</section>

<section anchor="profiling-this-document"><name>Profiling this document</name>
<t>This document is a general purpose high security profile of
OAuth 2.0 that has been proved by formal analysis to meet the stated
attacker model.</t>
<t>This document, and the underlying specifications, leave a number
of choices open to implementors, deployers and/or ecosystems. With
knowledge of the exact use cases, further reducing the number of
choices may further improve security, or make implementation or
interoperability easier.</t>
<t>However, for a profile to be compliant with this document, the
profile shall not remove or override mandatory behaviors, as doing
so is likely to invalidate the formal security analysis and reduce
security in potentially unpredictable ways.</t>
</section>
</section>

<section anchor="network-layer-protections"><name>Network layer protections</name>

<section anchor="requirements-for-all-endpoints"><name>Requirements for all endpoints</name>
<t>To protect against network attacks, clients, authorization servers, and resource
servers</t>

<ol spacing="compact">
<li>shall only offer TLS protected endpoints and shall establish connections
to other servers using TLS;</li>
<li>shall set up TLS connections using TLS version 1.2 or later;</li>
<li>shall follow the recommendations for Secure Use of Transport Layer Security in <xref target="BCP195"></xref>;</li>
<li>should use DNSSEC to protect against DNS spoofing attacks that can lead to
the issuance of rogue domain-validated TLS certificates; and</li>
<li>shall perform a TLS server certificate check, as per <xref target="RFC9525"></xref>.</li>
</ol>
<t><strong>NOTE 1</strong>: Even if an endpoint uses only organization validated (OV) or extended
validation (EV) TLS certificates, an attacker using rogue domain-validated
certificates is able to impersonate the endpoint and conduct man-in-the-middle
attacks. CAA records <xref target="RFC8659"></xref> help to mitigate this risk.</t>
</section>

<section anchor="requirements-for-endpoints-not-used-by-web-browsers"><name>Requirements for endpoints not used by web browsers</name>
<t>For server-to-server communication endpoints that are not used by web
browsers, the following requirements apply:</t>

<ol spacing="compact">
<li>When using TLS 1.2, servers shall only permit the cipher suites recommended in <xref target="BCP195"></xref>;</li>
<li>When using TLS 1.2, clients should only permit the cipher suites recommended in <xref target="BCP195"></xref>.</li>
</ol>

<section anchor="mtls-ecosystems"><name>MTLS ecosystems</name>
<t>Some ecosystems may implement MTLS as an additional security control at the transport layer
for all server-to-server endpoints requiring sensitive data being transmitted. For example, <tt>private_key_jwt</tt>
can be used for client authentication in conjunction with MTLS connectivity. To facilitate interoperability:</t>

<ul spacing="compact">
<li>MTLS ecosystems should provide the trust list of the certificate authorities;</li>
<li>authorization server implementations may utilize <tt>mtls_endpoint_aliases</tt> authorization server metadata as described in Section 5 of <xref target="RFC8705"></xref> to provide a discovery mechanism for endpoints that might have both MTLS and non-MTLS endpoints;</li>
<li>client implementations shall use client metadata <tt>use_mtls_endpoint_aliases</tt> (see <xref target="client-metadata"></xref>), if present, for endpoint communications.</li>
</ul>

<section anchor="client-metadata"><name>Client Metadata</name>
<t>The Dynamic Client Registration Protocol <xref target="RFC7591"></xref> defines an API
for dynamically registering OAuth 2.0 client metadata with authorization servers.
The metadata defined by <xref target="RFC7591"></xref>, and registered extensions to it,
also imply a general data model for clients that is useful for authorization server implementations
even when the dynamic client registration protocol isn't in play.
Such implementations will typically have some sort of user interface available for managing client configuration.</t>
<t>The following client metadata parameter is introduced by this specification:</t>

<ul spacing="compact">
<li><t><tt>use_mtls_endpoint_aliases</tt>:</t>

<ul spacing="compact">
<li>OPTIONAL. Boolean value indicating the requirement for a client to use mutual-TLS endpoint aliases <xref target="RFC8705"></xref> declared by the authorization server in its metadata even beyond the Mutual-TLS Client Authentication and Certificate-Bound Access Tokens use cases. If omitted, the default value is false.</li>
</ul></li>
</ul>
</section>
</section>
</section>

<section anchor="requirements-for-endpoints-used-by-web-browsers"><name>Requirements for endpoints used by web browsers</name>
<t>For endpoints that are used by web browsers, the following additional
requirements apply:</t>

<ol spacing="compact">
<li>Servers shall use methods to ensure that connections cannot be
 downgraded using TLS stripping attacks. A preloaded <xref target="preload"></xref> HTTP
 Strict Transport Security policy <xref target="RFC6797"></xref> can be used for this
 purpose. Some top-level domains, like <tt>.bank</tt> and <tt>.insurance</tt>,
 have set such a policy and therefore protect all second-level
 domains below them.</li>
<li>When using TLS 1.2, servers shall only use cipher suites allowed in
 <xref target="BCP195"></xref>.</li>
<li>Servers shall not support CORS <xref target="CORS.Protocol"></xref> for the authorization endpoint, as
 clients must perform an HTTP redirect rather than access this endpoint
 directly.</li>
</ol>
<t><strong>NOTE 1</strong>: When using TLS1.2 endpoints used by web browsers can use any cipher
suite allowed in <xref target="BCP195"></xref>, whereas endpoints not used by web browsers can only
use cipher suites recommended by <xref target="BCP195"></xref>.</t>
<t><strong>NOTE 2</strong>: New versions of <xref target="BCP195"></xref> will be published by the IETF periodically.
At a minimum, implementors are expected to become compliant with newly issued
versions of BCP195 within 12 months, or sooner.</t>
</section>
</section>

<section anchor="profile"><name>Profile</name>

<section anchor="general"><name>General</name>
<t>In the following, a profile of the following technologies is defined:</t>

<ul spacing="compact">
<li>OAuth 2.0 Authorization Framework <xref target="RFC6749"></xref></li>
<li>OAuth 2.0 Bearer Tokens <xref target="RFC6750"></xref></li>
<li>Proof Key for Code Exchange by OAuth Public Clients (PKCE) <xref target="RFC7636"></xref></li>
<li>OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access
Tokens (MTLS) <xref target="RFC8705"></xref></li>
<li>OAuth 2.0 Demonstrating Proof of Possession (DPoP)
<xref target="RFC9449"></xref></li>
<li>OAuth 2.0 Pushed Authorization Requests (PAR) <xref target="RFC9126"></xref></li>
<li>OAuth 2.0 Authorization Server Metadata <xref target="RFC8414"></xref></li>
<li>OAuth 2.0 Authorization Server Issuer Identification <xref target="RFC9207"></xref></li>
<li>OpenID Connect Core 1.0 incorporating errata set 1 <xref target="OIDC"></xref></li>
</ul>
</section>

<section anchor="requirements-for-authorization-servers"><name>Requirements for authorization servers</name>

<section anchor="general-requirements"><name>General requirements</name>
<t>Authorization servers</t>

<ol spacing="compact">
<li>shall distribute discovery metadata (such as the authorization endpoint) via
the metadata document as specified in <xref target="OIDD"></xref> and <xref target="RFC8414"></xref>;</li>
<li>shall reject requests using the resource owner password credentials grant;</li>
<li>shall only support confidential clients as defined in <xref target="RFC6749"></xref>;</li>
<li>shall only issue sender-constrained access tokens;</li>
<li><t>shall use one of the following methods for sender-constrained access tokens:</t>

<ul spacing="compact">
<li>MTLS as described in <xref target="RFC8705"></xref>,</li>
<li>DPoP as described in <xref target="RFC9449"></xref>;</li>
</ul></li>
<li><t>shall authenticate clients using one of the following methods:</t>

<ul spacing="compact">
<li>MTLS as specified in Section 2 of <xref target="RFC8705"></xref>, or</li>
<li><tt>private_key_jwt</tt> as specified in Section 9 of <xref target="OIDC"></xref>;</li>
</ul></li>
<li>shall not expose open redirectors (see Section 4.11 of
 <xref target="I-D.ietf-oauth-security-topics"></xref>);</li>
<li>shall only accept its issuer identifier value (as defined in <xref target="RFC8414"></xref>) as a string in the
<tt>aud</tt> claim received in client authentication assertions;</li>
<li>shall not use refresh token rotation except in extraordinary circumstances (see Note 1 below);</li>
<li>if using DPoP, may use the server provided nonce mechanism (as defined in Section 8 of <xref target="RFC9449"></xref>);</li>
<li>shall issue authorization codes with a maximum lifetime of 60 seconds;</li>
<li>if using DPoP, shall support &quot;Authorization Code Binding to DPoP Key&quot; (as required by Section 10.1 of <xref target="RFC9449"></xref>);</li>
<li>to accommodate clock offsets, shall accept JWTs with an <tt>iat</tt> or <tt>nbf</tt> timestamp between 0
and 10 seconds in the future but shall reject JWTs with an <tt>iat</tt> or <tt>nbf</tt> timestamp greater than
60 seconds in the future. See Note 3 for further details and rationale; and</li>
<li>should restrict the privileges associated with an access token to the minimum required for
the particular application or use case.</li>
</ol>
<t><strong>NOTE 1</strong>:
The use of refresh token rotation does not provide security benefits when used with
confidential clients and sender-constrained access tokens. This specification prohibits
the use of refresh token rotation for security reasons as it causes user experience
degradation and operational issues whenever the client fails to store or receive the new
refresh token and has no option to retry.</t>
<t>However, as refresh token rotation may be required from time to time for infrastructure
migration or similar extraordinary circumstances, this specification allows it, provided that
authorization servers offer clients the time-limited option to retry with the old refresh
token in case of failure. Implementers need to consider a secure mechanism for clients
to recover from a loss of a new refresh token on issue. The details of this mechanism are
outside the scope of this specification.</t>
<t><strong>NOTE 2</strong>:
This document is structured to support a variety of grants to be used with the general
requirements above. For example the client credentials grant or the  IBA grant <xref target="CIBA"></xref>.
Implementers should note that as of the time of writing only the authorization code flow and CIBA
flows have been through a detailed security analysis <xref target="FAPI2SEC"></xref>.</t>
<t><strong>NOTE 3</strong>:
Clock skew is a cause of many interoperability issues. Even a few hundred milliseconds of clock
skew can cause JWTs to be rejected for being &quot;issued in the future&quot;. The DPoP specification
<xref target="RFC9449"></xref> suggests that JWTs  are accepted in the reasonably near future (on the order of seconds
or minutes). This document goes further by requiring authorization servers to accept JWTs that
have timestamps up to 10 seconds in the future. 10 seconds was chosen as a value that does not
affect security while greatly increasing interoperability. Implementers are free to accept JWTs
with a timestamp of up to 60 seconds in the future. Some ecosystems have found that the value of 30 seconds
is needed to fully eliminate clock skew issues. To prevent implementations switching off
<tt>iat</tt> and <tt>nbf</tt> checks completely this document imposes a maximum timestamp in the future of 60 seconds.</t>
</section>

<section anchor="authorization-endpoint-flows"><name>Authorization endpoint flows</name>
<t>For flows that use the authorization endpoint, authorization servers</t>

<ol spacing="compact">
<li>shall require the value of <tt>response_type</tt> described in <xref target="RFC6749"></xref> to be <tt>code</tt>;</li>
<li>shall support client-authenticated pushed authorization requests
according to <xref target="RFC9126"></xref>;</li>
<li>shall reject authorization requests sent without <xref target="RFC9126"></xref>;</li>
<li>shall reject pushed authorization requests without client authentication;</li>
<li>shall require PKCE <xref target="RFC7636"></xref> with <tt>S256</tt> as the code challenge method;</li>
<li>shall require the <tt>redirect_uri</tt> parameter in pushed authorization requests;</li>
<li>shall return an <tt>iss</tt> parameter in the authorization response according to <xref target="RFC9207"></xref>;</li>
<li>shall not transmit authorization responses over unencrypted network
 connections, and, to this end, shall not allow redirect URIs that use the
 &quot;http&quot; scheme except for native clients that use loopback interface
 Redirection as described in Section 7.3 of <xref target="RFC8252"></xref>;</li>
<li>shall reject an authorization code (Section 1.3.1 of <xref target="RFC6749"></xref>) if it has
 been previously used;</li>
<li>shall not use the HTTP 307 status code when redirecting a request that contains
 user credentials to avoid forwarding the credentials to a third party accidentally
 (see Section 4.12 of <xref target="I-D.ietf-oauth-security-topics"></xref>);</li>
<li>should use the HTTP 303 status code when redirecting the user agent using status codes;</li>
<li>shall issue pushed authorization requests <tt>request_uri</tt> with <tt>expires_in</tt> values
 of less than 600 seconds;</li>
<li>should provide end-users with all necessary information to make an
informed decision about whether to consent to the authorization
request, including the identity of the client and the scope of the
authorization; and</li>
<li>if supporting <xref target="OIDC"></xref>, shall support nonce parameter values up to 64 characters in length,
may reject nonce values longer than 64 characters.</li>
</ol>
<t><strong>NOTE 1</strong>:
If replay identification of the authorization code is not possible, it
is desirable to set the validity period of the authorization code to one minute
or a suitable short period of time. The validity period may act as a cache
control indicator of when to clear the authorization code cache if one is used.</t>
<t><strong>NOTE 2</strong>:
The <tt>request_uri</tt> <tt>expires_in</tt> time must be sufficient for
the user's device to receive the link and the user to complete the
process of opening the link. In many cases (poor network connection or
where the user has to manually select the browser to be used) this can
easily take over 30 seconds.</t>
<t><strong>NOTE 3</strong>: It is recommended that authorization servers that enforce one-time
use of <tt>request_uri</tt> values ensure the enforcement takes place at
the point of authorization, not at the point of loading an authorization page.
This prevents user software that preloads urls from invalidating the
<tt>request_uri</tt>.</t>
<t><strong>NOTE 4</strong>: In this document the state parameter is not used for CSRF protection,
but may be used to by the client for application state. In circumstances where
clients encode application state in a JWT the length of the state parameter
value could be in excess of 1000 characters.</t>
<t><strong>NOTE 5</strong>: The use of OAuth 2.0 Rich Authorization Requests (RAR) <xref target="RFC9396"></xref>
is recommended when the <tt>scope</tt> parameter is not expressive enough to convey
the authorization that a client may want to obtain.</t>
</section>

<section anchor="returning-authenticated-user-s-identifier"><name>Returning authenticated user's identifier</name>
<t>If it is desired to provide the authenticated user's identifier to the client in
the token response, the authorization server shall support OpenID Connect
<xref target="OIDC"></xref>.</t>
</section>
</section>

<section anchor="requirements-for-clients"><name>Requirements for clients</name>

<section anchor="general-requirements-1"><name>General requirements</name>
<t>Clients</t>

<ol spacing="compact">
<li><t>shall support sender-constrained access tokens using one or both of the following methods:</t>

<ul spacing="compact">
<li>MTLS as described in <xref target="RFC8705"></xref>,</li>
<li>DPoP as described in <xref target="RFC9449"></xref>;</li>
</ul></li>
<li><t>shall support client authentication using one or both of the following methods:</t>

<ul spacing="compact">
<li>MTLS as specified in Section 2 of <xref target="RFC8705"></xref>,</li>
<li><tt>private_key_jwt</tt> as specified in Section 9 of <xref target="OIDC"></xref>;</li>
</ul></li>
<li>shall send access tokens in the HTTP header as in Section 2.1 of OAuth 2.0
Bearer Token Usage <xref target="RFC6750"></xref> or Section 7.1 of DPoP <xref target="RFC9449"></xref>;</li>
<li>shall not expose open redirectors (see Section 4.11 of
 <xref target="I-D.ietf-oauth-security-topics"></xref>);</li>
<li>if using <tt>private_key_jwt</tt>, shall use the authorization server's
issuer identifier value (as defined in <xref target="RFC8414"></xref>) in the <tt>aud</tt>
claim in client authentication assertions. The issuer identifier value
shall be sent as a string not as an item in an array.</li>
<li>shall support refresh tokens and their rotation;</li>
<li>if using MTLS client authentication or MTLS sender-constrained access tokens, shall support
the <tt>mtls_endpoint_aliases</tt> metadata defined in <xref target="RFC8705"></xref>;</li>
<li>if using DPoP, shall support the server provided nonce mechanism (as defined in Section 8 of <xref target="RFC9449"></xref>);</li>
<li>shall only use authorization server metadata (such as the authorization endpoint) retrieved from the metadata document as specified in <xref target="OIDD"></xref> and <xref target="RFC8414"></xref>;</li>
<li>shall ensure that the issuer URL used as the basis for retrieving the authorization server metadata is obtained from an authoritative source and using a secure channel, such that it cannot be modified by an attacker;</li>
<li>shall ensure that this issuer URL and the <tt>issuer</tt> value in the obtained metadata match;</li>
<li>shall initiate an authorization process only with the end-user's
explicit or implicit consent and protect initiation of an
authorization process against cross-site request forgery, thereby
enabling the end-user to be aware of the context in which a flow was
started; and</li>
<li>should request authorization with the least privileges necessary for the specific application
or use case.</li>
</ol>
<t><strong>NOTE 1</strong>:
This profile may be used by confidential clients on a user-controlled device where the system
clock may not be accurate, causing <tt>private_key_jwt</tt> client authentication to fail.
In such circumstances a client should consider using the HTTP date header returned from the
server to synchronize its own clock when generating client assertions.</t>
<t><strong>NOTE 2</strong>:
Although authorization servers are required to support &quot;Authorization
Code Binding to DPoP Key&quot; (as defined by Section 10.1 of
<xref target="RFC9449"></xref>), clients are not required to use it.</t>
</section>

<section anchor="authorization-code-flow"><name>Authorization code flow</name>
<t>For the authorization code flow, clients</t>

<ol spacing="compact">
<li>shall use the authorization code grant described in <xref target="RFC6749"></xref>;</li>
<li>shall use pushed authorization requests according to <xref target="RFC9126"></xref>;</li>
<li>shall use PKCE <xref target="RFC7636"></xref> with <tt>S256</tt> as the code challenge method;</li>
<li>shall generate the PKCE challenge specifically for each authorization request and securely bind the challenge to the client and the user agent in which the flow was started;</li>
<li>shall check the <tt>iss</tt> parameter in the authorization response according to <xref target="RFC9207"></xref> to prevent mix-up attacks;</li>
<li>shall only send <tt>client_id</tt> and <tt>request_uri</tt> request parameters to the authorization endpoint (all other authorization request parameters are sent in the pushed authorization request according to <xref target="RFC9126"></xref>);</li>
<li>if using <xref target="OIDC"></xref>, should not use nonce parameter values longer than 64 characters.</li>
</ol>
<t><strong>NOTE 1:</strong> The recommended restrictions on the nonce parameter value length is to aid interoperability.</t>
</section>
</section>

<section anchor="requirements-for-resource-servers"><name>Requirements for resource servers</name>
<t>The FAPI 2.0 endpoints are OAuth 2.0 protected resource endpoints that return
protected information for the resource owner associated with the submitted
access token.</t>
<t>Resource servers with the FAPI endpoints</t>

<ol spacing="compact">
<li>shall accept access tokens in the HTTP header as in Section 2.1 of OAuth 2.0
Bearer Token Usage <xref target="RFC6750"></xref> or Section 7.1 of DPoP <xref target="RFC9449"></xref>;</li>
<li>shall not accept access tokens in the query parameters stated in Section 2.3
of OAuth 2.0 Bearer Token Usage <xref target="RFC6750"></xref>;</li>
<li>shall verify the validity, integrity, expiration and revocation status of
access tokens;</li>
<li>shall verify that the authorization represented by the access token is sufficient
for the requested resource access and otherwise return errors as in Section 3.1
of <xref target="RFC6750"></xref>; and</li>
<li><t>shall support and verify sender-constrained access tokens using one or both of the following methods:</t>

<ul spacing="compact">
<li>MTLS as described in <xref target="RFC8705"></xref>,</li>
<li>DPoP as described in <xref target="RFC9449"></xref>.</li>
</ul></li>
</ol>
</section>
</section>

<section anchor="cryptography-and-secrets"><name>Cryptography and secrets</name>

<section anchor="general-requirements-2"><name>General requirements</name>
<t>The following requirements apply to cryptographic operations and secrets:</t>

<ol>
<li><t>Authorization servers, clients, and resource servers when creating or processing JWTs shall</t>

<ol spacing="compact">
<li>adhere to <xref target="RFC8725"></xref>;</li>
<li>use <tt>PS256</tt>, <tt>ES256</tt>, or <tt>EdDSA</tt> (using the <tt>Ed25519</tt> variant) algorithms; and</li>
<li>not use or accept the <tt>none</tt> algorithm.</li>
</ol></li>
<li><t>RSA keys shall have a minimum length of 2048 bits.</t>
</li>
<li><t>Elliptic curve keys shall have a minimum length of 224 bits.</t>
</li>
<li><t>Credentials not intended for handling by end-users (e.g., access tokens,
refresh tokens, authorization codes, etc.) shall be created with at least
128 bits of entropy such that an attacker correctly guessing the value is
computationally infeasible. Cf. Section 10.10 of <xref target="RFC6749"></xref>.</t>
</li>
</ol>
<t>Note: As of the time of writing there isn't a <eref target="https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms">registered</eref> fully-specified algorithm describing &quot;<tt>EdDSA</tt> using the <tt>Ed25519</tt> variant&quot;. If such algorithm is registered in the future, it is also allowed to be used for this profile.</t>
</section>

<section anchor="json-web-key-sets"><name>JSON Web Key Sets</name>
<t>This profile supports the use of <tt>private_key_jwt</tt> and in addition allows the use of
OpenID Connect. When these are used clients and authorization servers need to verify
payloads with keys from another party. For authorization servers this profile strongly
recommends  the use of JWKS URI endpoints to distribute public keys. For client's key
management this profile recommends either the use of JWKS URI endpoints or the use of
the <tt>jwks</tt> parameter in combination with <xref target="RFC7591"></xref> and <xref target="RFC7592"></xref>.</t>
<t>The definition of the authorization server <tt>jwks_uri</tt> can be found in <xref target="RFC8414"></xref>,
while the definition of the client <tt>jwks_uri</tt> can be found in <xref target="RFC7591"></xref>.</t>
<t>In addition, any server providing a <tt>jwks_uri</tt> endpoint</t>

<ol spacing="compact">
<li>shall only serve the <tt>jwks_uri</tt> endpoint over TLS;</li>
<li>should not use the JOSE headers for <tt>x5u</tt> and <tt>jku</tt>; and</li>
<li>should not serve a JWK set with multiple keys with the same <tt>kid</tt>.</li>
</ol>
</section>

<section anchor="handling-duplicate-key-identifiers"><name>Handling Duplicate Key Identifiers</name>
<t>JWK sets should not contain multiple keys with the same <tt>kid</tt>. However, to increase
interoperability when there are multiple keys with the same <tt>kid</tt>,  the verifier shall
consider other JWK attributes, such as <tt>kty</tt>, <tt>use</tt>, <tt>alg</tt>, etc., when selecting the
verification key for the particular JWS message. For example, the following algorithm
could be used in selecting which key to use to verify a message signature:</t>

<ol spacing="compact">
<li>find keys with a <tt>kid</tt> that matches the <tt>kid</tt> in the JOSE header;</li>
<li>if a single key is found, use that key;</li>
<li>if multiple keys are found, then the verifier should iterate through the keys until a key is found that has a matching <tt>alg</tt>, <tt>use</tt>, <tt>kty</tt>, or <tt>crv</tt> that corresponds to the message being verified.</li>
</ol>
</section>
</section>

<section anchor="main-differences-to-fapi-1-0"><name>Main differences to FAPI 1.0</name>
<table>
<thead>
<tr>
<th align="left">FAPI 1.0 - Part 2: Advanced</th>
<th align="left">FAPI 2.0</th>
<th align="left">Reasons</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">JAR</td>
<td align="left">PAR</td>
<td align="left">integrity protection and compatibility improvements for authorization requests</td>
</tr>

<tr>
<td align="left">JARM</td>
<td align="left">only code in response</td>
<td align="left">the authorization response is reduced to only contain the authorization code, obsoleting the need for integrity protection</td>
</tr>

<tr>
<td align="left">BCM principles, defences based on particular threats</td>
<td align="left">attacker model, security goals, best practices from the OAuth Security BCP</td>
<td align="left">clearer design guideline, suitability for formal analysis</td>
</tr>

<tr>
<td align="left"><tt>s_hash</tt></td>
<td align="left">PKCE</td>
<td align="left">protection provided by <tt>state</tt> (in particular against CSRF) is now provided by PKCE; <tt>state</tt> integrity is partially protected by PAR</td>
</tr>

<tr>
<td align="left">pre-registered redirect URIs</td>
<td align="left">redirect URIs in PAR</td>
<td align="left">pre-registration is not required with client authentication and PAR</td>
</tr>

<tr>
<td align="left">response types <tt>code id_token</tt> or <tt>code</tt></td>
<td align="left">response type <tt>code</tt></td>
<td align="left">no ID token in front-channel (privacy improvement); nonce/signature check can be skipped by clients, PKCE cannot (security improvement)</td>
</tr>

<tr>
<td align="left">ID Token as detached signature</td>
<td align="left">PKCE</td>
<td align="left">ID token does not need to serve as a detached signature</td>
</tr>

<tr>
<td align="left">potentially encrypted ID Tokens in the front channel</td>
<td align="left">No ID Tokens in the front channel (therefore no encryption required)</td>
<td align="left">ID Tokens are only exchanged in the back channel and as such do not need to be encrypted</td>
</tr>

<tr>
<td align="left"><tt>nbf</tt> &amp; <tt>exp</tt> claims in request object</td>
<td align="left"><tt>request_uri</tt> has limited lifetime</td>
<td align="left">Prevents pre-generation of requests</td>
</tr>

<tr>
<td align="left"><tt>x-fapi-*</tt> headers</td>
<td align="left">Moved to Implementation and Deployment Advice document</td>
<td align="left">Not relevant to the core of the security profile</td>
</tr>

<tr>
<td align="left">MTLS for sender-constrained access tokens</td>
<td align="left">MTLS or DPoP</td>
<td align="left">Due to the lack of the tight integration with the TLS layer, DPoP can be easier to deploy in some scenarios</td>
</tr>
</tbody>
</table></section>
</section>

<section anchor="security-considerations"><name>Security considerations</name>

<section anchor="access-token-lifetimes"><name>Access token lifetimes</name>
<t>The use of short-lived access tokens (combined with refresh tokens) potentially reduces the time window for some attacks.</t>
<t>The use of refresh tokens also allows clients to rotate their sender-constraining keys without loss of grants, either because of compromise of the key or as part of good security hygiene.</t>
<t>If issuing long-lived grants (e.g. days/weeks), consider using short-lived (e.g. minutes/hours) access tokens combined with refresh tokens.</t>
<t>There is a performance and resiliency trade-off, setting the access token lifetime too short can increase the load on and dependency on the authorization server.</t>
</section>

<section anchor="dpop-proof-replay"><name>DPoP proof replay</name>
<t>An attacker of type A5 (see <xref target="attackermodel"></xref>) may be able to obtain DPoP proofs
that they can then replay.</t>
<t>This may also allow reuse of the DPoP proof with an altered request, as DPoP does
not sign the body of HTTP requests nor most headers. For example, for a payment request
the attacker might be able to specify a different amount or destination account.</t>
<t>Possible mitigations for this are:</t>

<ol spacing="compact">
<li>Resource servers use short-lived DPoP nonces to reduce the time window where a request can be replayed.</li>
<li>Resource servers implement replay prevention using the <tt>jti</tt> header as explained in <xref target="RFC9449"></xref>.</li>
<li>Replay of an altered request can be prevented by using signed resource requests as per FAPI Message Signing <xref target="FAPIMessageSigning"></xref>.</li>
<li>Consider MTLS sender-constraining instead of DPoP.</li>
</ol>
<t>These mitigations may have potential complexity, performance or scalability trade-offs. Attacker type A5
represents a powerful attacker and mitigations may not be necessary for many ecosystems.</t>
</section>

<section anchor="injection-of-stolen-access-tokens"><name>Injection of stolen access tokens</name>
<t>There are potential situations where the attacker may be able to inject stolen access
tokens into a client to bypass <xref target="RFC8705"></xref> or <xref target="RFC9449"></xref>
sender-constraining of the access token, as described in &quot;Cuckoo's Token Attack&quot; in
<xref target="FAPI1SEC"></xref>.</t>
<t>A pre-condition for this attack is that the attacker has control of an authorization
server that is trusted by the client to issue access tokens for the target resource
server. An attacker may obtain control of an authorization server by:</t>

<ol spacing="compact">
<li>compromising the security of a different authorization server that the client trusts;</li>
<li>acting as an authorization server and establishing a trust relationship with a client using social engineering; or</li>
<li>compromising the client.</li>
</ol>
<t>The attack may be easier if a centralized directory or other resource server discovery mechanism allows the attacker to
cause the client to send the stolen access token received from the attacker-controlled authorization server to an honest
resource server.</t>
<t>The pre-conditions for this attack do not apply to many ecosystems and require a powerful attacker. In situations
where the pre-conditions may be met, the possible mitigations include:</t>

<ol spacing="compact">
<li>clients using different DPoP keys or MTLS certificates at each authorization server;</li>
<li>clients sending the issuer identifier the access token was obtained from to the resource server, and requiring
resource servers to verify the issuer matches the authorization server that originally issued the token (though
there is no standardized method for clients to send the issuer to the resource server);</li>
<li>reducing the time window for the attack by using short-lived access tokens alongside refresh tokens.</li>
</ol>
</section>

<section anchor="authorization-request-leaks-lead-to-csrf"><name>Authorization request leaks lead to CSRF</name>
<t>An attacker of type A3 (see <xref target="attackermodel"></xref>) can intercept an authorization request, log in at the
authorization server, receive an authorization code and redirect the honest user via a cross-site request forgery (CSRF) attack to
the honest client but with the attacker's authorization code. This results in the user accessing the
attacker's resources, thus breaking session integrity.</t>
<t>It is important to note that all practically used redirect-based flows are
susceptible to this attack, as redirection does not allow for a tight coupling
of the session between the user's browser and the client on the one side and the
session between the user's browser and the authorization server on the other
side.  This attack, however, requires a strong attacker who can read
authorization requests and perform a CSRF attack in a short time window.</t>
<t>Possible mitigations for this are:</t>

<ol spacing="compact">
<li>Requiring the authorization server to only accept a <tt>request_uri</tt> once. This
will prevent attacks where the attacker was able to read the authorization
request, but not use the <tt>request_uri</tt> before the honest user does so.</li>
<li>Requiring the client to only make one authorization code grant call for each
authorization endpoint call. This will prevent attacks where the attacker was
unable to send the authorization response before the honest user does so.</li>
<li>Reducing the lifetime of the authorization code - this will reduce the window
in which the CSRF attack has to be performed.</li>
</ol>
<t>An attacker that has the option to block a user's request completely can
circumvent the first and second defences. In practice, however, attackers can
often read an authorization request (e.g., from a log file or via some other
side-channel), but not block the request from being sent. If the victim's
internet connection is slow, this might increase the attacker's chances.</t>
</section>

<section anchor="browser-swapping-attacks"><name>Browser-swapping attacks</name>
<t>An attacker that has access to the authorization response sent through a
victim's browser can perform a browser-swapping attack as follows:</t>

<ol spacing="compact">
<li>The attacker starts a new flow using their own browser and some
client. The client sends a pushed authorization request to the
authorization server and receives a <tt>request_uri</tt> in the response.
The client then redirects the attacker's browser to the
authorization server.</li>
<li>The attacker intercepts this redirection and forwards the URL to a
victim. For example, the attacker can embed a link to this URL in a
phishing website, an email, or a QR code.</li>
<li>The victim may be tricked into believing that an
authentication/authorization is legitimately required. The victim
therefore authenticates at the authorization server and may grant
the client access to their data.</li>
<li>The attacker can now intercept the authorization response in the
victim's browser and forward it to the client using their own browser.</li>
<li>The client will recognize that the authorization response belongs to
the same browser that initially started the transaction (the
attacker's browser) and exchange the authorization code for an
access token and/or obtain user information.</li>
<li>Via the client, the attacker now has access to the user's resources
or is logged in as the user.</li>
</ol>
<t>With currently deployed technology, there is no way to completely
prevent this attack if the authorization response leaks to an attacker
in any redirect-based protocol. It is therefore important to keep the
authorization response confidential. The requirements in this security
profile are designed to achieve that, e.g., by disallowing open
redirectors and requiring that the <tt>redirect_uri</tt> is sent via an
authenticated and encrypted channel, the pushed authorization request,
ensuring that the <tt>redirect_uri</tt> cannot be manipulated by the attacker.</t>
<t>Implementers need to consider the confidentiality of the authorization
response critical when designing their systems, in particular when this
security profile is used in other contexts, e.g., mobile applications.</t>
</section>

<section anchor="incomplete-or-incorrect-implementations-of-the-specifications"><name>Incomplete or incorrect implementations of the specifications</name>
<t>To achieve the full security and interoperability benefits, it is important that
the implementation of this document and the underlying OpenID Connect and
OAuth specifications is both complete and correct.</t>
<t>The OpenID Foundation provides tools that can be used to confirm that an
implementation is correct:</t>
<t><eref target="https://openid.net/certification/">https://openid.net/certification/</eref></t>
<t>The OpenID Foundation maintains a list of certified implementations:</t>
<t><eref target="https://openid.net/developers/certified/">https://openid.net/developers/certified/</eref></t>
<t>Deployments that use this document should use certified implementations.</t>
</section>

<section anchor="client-impersonating-resource-owner"><name>Client Impersonating Resource Owner</name>
<t>Section 4.15 of <xref target="I-D.ietf-oauth-security-topics"></xref> describes an attack where a malicious client is able to
influence its client_id such that it could be mistaken for an end-user subject identifier. This attack
also requires that an authorization server issues access tokens with similar privileges to both clients
and end-users.</t>
<t>For this reason, authorization servers should not allow clients to influence their client_id in a way
that it can be mistaken for an end-user subject identifier.</t>
</section>

<section anchor="key-compromise"><name>Key Compromise</name>
<t>In the event that a cryptographic key is compromised, it is important to limit the impact of such an event.
This can be achieved by:</t>

<ol>
<li><t>Key rotation: automated regular key rotation is recommended, as it reduces the time window in which a compromised key can be used.
jwks_uri endpoints allows parties to rotate their keys without the need for manual, error-prone coordination.</t>
</li>
<li><t>Key scope: single purpose keys are recommended. For example, it is not recomended to use the same key for signing and encryption. See
Section 5.2 of <xref target="NIST.SP.800-57pt1r5"></xref> for further guidance.</t>
</li>
<li><t>Stateful credentials: It is recommended that implementers consider the trade-offs between stateful and stateless
credentials, such as access tokens. In the event of a key compromise, the use of stateless tokens signed by the
compromised key could enable an attacker to forge tokens. This risk can be mitigated if all tokens are stateful,
meaning there is a mechanism to validate each token's active status through a central authority or database. However,
stateless tokens offer significant advantages. They carry all necessary information within themselves,
improving performance by removing the need for server-side database lookups and eliminating central session data
storage. Additionally, they can be parsed and validated by resource servers directly, without further authorization
server involvement. This enhances scalability and flexibility, particularly in scenarios where the authorization
server and resource server are not co-located or managed by the same entity (as discussed in the introduction
to <xref target="RFC9068"></xref>).</t>
</li>
<li><t>Credential linking: When multiple credentials are issued as part of the same authorization, it is recommended
that their relationship be explicitly established and recorded. This way, if one credential in a linked set is
compromised, all related credentials can be revoked.</t>
</li>
</ol>
</section>
</section>

<section anchor="privacy-considerations"><name>Privacy considerations</name>
<t>There are many factors to be considered in terms of privacy when implementing
this document. Since this document is a profile of OAuth 2.0 and
OpenID Connect, the privacy considerations are not specific to this document and
generally apply to OAuth or OpenID Connect. Implementers are advised to perform
a thorough privacy impact assessment and manage identified risks appropriately.</t>
<t><strong>NOTE 1:</strong> Implementers can consult documents like <xref target="ISO29100"></xref> and <xref target="ISO29134"></xref> for this
purpose.</t>
<t>Privacy threats to OAuth and OpenID Connect implementations include the following:</t>

<ul spacing="compact">
<li><strong>Inappropriate privacy notice</strong>:  A privacy notice (e.g., provided at a
<tt>policy_url</tt>) or by other means can be inappropriate or insufficient.</li>
<li><strong>Inadequate choice</strong>:  Providing a consent screen without adequate choices
does not form consent.</li>
<li><strong>Misuse of data</strong>:  An authorization server, resource server or client can
potentially use the data not according to the purpose that was agreed.</li>
<li><strong>Collection minimization violation</strong>:  A client asking for more data than
it absolutely needs to fulfill the purpose is violating the collection
minimization principle.</li>
<li><strong>Unsolicited personal data from the resource server</strong>:  Some bad resource
server implementations may return more data than requested. If the data is
personal data, then this would be a violation of privacy principles.</li>
<li><strong>Data minimization violation</strong>:  Any process that is processing more data
than it needs is violating the data minimization principle.</li>
<li><strong>Authorization servers tracking end-users</strong>:  Authorization servers
identifying what data is being provided to which client for which end-user.</li>
<li><strong>End-user tracking by clients</strong>:  Two or more clients correlating access
tokens or ID Tokens to track users.</li>
<li><strong>Client misidentification by end-users</strong>:  End-user misunderstands who the
client is due to a confusing representation of the client at the
authorization server's authorization page.</li>
<li><strong>Insufficient understanding of the end-user granting access to data</strong>: To
enhance the trust of the ecosystem, best practice is for the authorization
server to make clear what is included in the authorization request (for
example, what data will be released to the client).</li>
<li><strong>Attacker observing personal data in authorization request/response</strong>:  The authorization request or response might contain personal
data. In some jurisdictions, even security parameters can be considered
personal data. This profile aims to reduce the data sent in the
authorization request and response to an absolute minimum, but nonetheless,
an attacker might observe some data.</li>
<li><strong>Data leak from authorization server</strong>:  The authorization server generally
stores personal data. If it becomes compromised, this data can leak or be
modified.</li>
<li><strong>Data leak from resource servers</strong>:  Some resource servers store personal
data. If a resource server becomes compromised, this data can leak or be
modified.</li>
<li><strong>Data leak from clients</strong>:  Some clients store personal data. If the client
becomes compromised, this data can leak or be modified.</li>
</ul>
</section>

<section anchor="iana-considerations"><name>IANA Considerations</name>

<section anchor="oauth-dynamic-client-registration-metadata-registration"><name>OAuth Dynamic Client Registration Metadata registration</name>
<t>This specification requests registration of the following client metadata
definitions in the IANA &quot;OAuth Dynamic Client Registration Metadata&quot; registry
established by <xref target="RFC7591"></xref>:</t>

<section anchor="registry-contents"><name>Registry Contents</name>

<ul spacing="compact">
<li>Client Metadata Name: <tt>use_mtls_endpoint_aliases</tt></li>
<li>Client Metadata Description: Boolean value indicating the requirement for a client to use mutual-TLS endpoint aliases <xref target="RFC8705"></xref> declared by the authorization server in its metadata even beyond the Mutual-TLS Client Authentication and Certificate-Bound Access Tokens use cases.</li>
<li>Change Controller: OpenID Foundation FAPI Working Group - openid-specs-fapi@lists.openid.net</li>
<li>Specification Document(s): <xref target="client-metadata"></xref> of this specification</li>
</ul>
</section>
</section>
</section>

</middle>

<back>
<references><name>Normative References</name>
<reference anchor="BCP195" target="https://www.rfc-editor.org/info/bcp195">
  <front>
    <title>BCP195</title>
    <author>
      <organization>IETF</organization>
    </author>
  </front>
</reference>
<reference anchor="CORS.Protocol" target="https://fetch.spec.whatwg.org/#http-cors-protocol">
  <front>
    <title>CORS Protocol</title>
    <author>
      <organization>WHATWG</organization>
    </author>
  </front>
</reference>
<reference anchor="ISO29100" target="https://www.iso.org/standard/85938.html">
  <front>
    <title>ISO/IEC 29100 Information technology – Security techniques – Privacy framework</title>
    <author fullname="ISO/IEC">
      <organization></organization>
    </author>
  </front>
</reference>
<reference anchor="OIDC" target="http://openid.net/specs/openid-connect-core-1_0.html">
  <front>
    <title>OpenID Connect Core 1.0 incorporating errata set 1</title>
    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>NRI</organization>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
    </author>
    <author fullname="Mike Jones" initials="M." surname="Jones">
      <organization>Microsoft</organization>
    </author>
    <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
      <organization>Google</organization>
    </author>
    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
      <organization>Salesforce</organization>
    </author>
    <date year="2014" month="Nov" day="8"></date>
  </front>
</reference>
<reference anchor="OIDD" target="https://openid.net/specs/openid-connect-discovery-1_0.html">
  <front>
    <title>OpenID Connect Discovery 1.0 incorporating errata set 1</title>
    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>NRI</organization>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
    </author>
    <author fullname="Mike Jones" initials="M." surname="Jones">
      <organization>Microsoft</organization>
    </author>
    <author fullname="Edmund Jay" initials="E." surname="Jay">
      <organization>Illumila</organization>
    </author>
    <date year="2014" month="Nov" day="8"></date>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8414.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8725.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9126.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9207.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9449.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9525.xml"/>
<reference anchor="attackermodel" target="https://openid.net/specs/fapi-2_0-attacker-model.html">
  <front>
    <title>FAPI 2.0 Attacker Model</title>
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>Authlete</organization>
    </author>
    <date year="2022" month="Nov" day="14"></date>
  </front>
</reference>
</references>
<references><name>Informative References</name>
<reference anchor="CIBA" target="http://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html">
  <front>
    <title>OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0</title>
    <author fullname="Gonzalo Fernandez Rodriguez" initials="G." surname="Fernandez Rodriguez">
      <organization>Telefonica I+D</organization>
    </author>
    <author fullname="Florian Walter" initials="F." surname="Walter">
      <organization>Deutsche Telekom AG</organization>
    </author>
    <author fullname="Axel Nennker" initials="A." surname="Nennker">
      <organization>Deutsche Telekom AG</organization>
    </author>
    <author fullname="Dave Tonge" initials="D." surname="Tonge">
      <organization>Moneyhub</organization>
    </author>
    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
    </author>
    <date year="2021" month="September" day="1"></date>
  </front>
</reference>
<reference anchor="FAPI1SEC" target="https://arxiv.org/abs/1901.11520">
  <front>
    <title>An Extensive Formal Security Analysis of the OpenID Financial-grade API</title>
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>yes.com AG</organization>
    </author>
    <author fullname="Pedram Hosseyni" initials="P." surname="Hosseyni">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <author fullname="Ralf Kuesters" initials="R." surname="Kuesters">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <date year="2019" month="Jan" day="31"></date>
  </front>
</reference>
<reference anchor="FAPI2SEC" target="https://doi.ieeecomputersociety.org/10.1109/CSF61375.2024.00002">
  <front>
    <title>Formal Security Analysis of the OpenID Financial-grade API 2.0</title>
    <author fullname="Pedram Hosseyni" initials="P." surname="Hosseyni">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <author fullname="Ralf Kuesters" initials="R." surname="Kuesters">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <author fullname="Tim Würtele" initials="T." surname="Würtele">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <date year="2024" month="Jul" day="08"></date>
  </front>
</reference>
<reference anchor="FAPIMessageSigning" target="https://openid.net/specs/fapi-2_0-message-signing-ID1.html">
  <front>
    <title>FAPI 2.0 Message Signing</title>
    <author fullname="Dave Tonge" initials="D." surname="Tonge">
      <organization>Moneyhub Financial Technology</organization>
    </author>
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>Authlete</organization>
    </author>
    <date year="2024" month="January" day="17"></date>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-oauth-security-topics.xml"/>
<reference anchor="ISO29134" target="https://www.iso.org/standard/86012.html">
  <front>
    <title>ISO/IEC 29134 Information technology – Security techniques – Guidelines for privacy impact assessment</title>
    <author fullname="ISO/IEC">
      <organization></organization>
    </author>
  </front>
</reference>
<reference anchor="ISODIR2" target="https://www.iso.org/sites/directives/current/part2/index.xhtml">
  <front>
    <title>ISO/IEC Directives, Part 2 - Principles and rules for the structure and drafting of ISO and IEC documents</title>
    <author fullname="ISO/IEC">
      <organization>ISO/IEC</organization>
    </author>
  </front>
</reference>
<reference anchor="NIST.SP.800-57pt1r5" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">
  <front>
    <title>NIST Special Publication 800-57 Part 1 Revision 5</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="Allen Roginsky ">
      <organization></organization>
    </author>
    <date year="2020" month="May" day="01"></date>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6797.xml"/>
<reference anchor="RFC7591" target="https://datatracker.ietf.org/doc/html/rfc7591">
  <front>
    <title>OAuth 2.0 Dynamic Client Registration Protocol</title>
    <author>
      <organization>IETF</organization>
    </author>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7592.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8659.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8705.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9068.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9396.xml"/>
<reference anchor="preload" target="https://hstspreload.org/">
  <front>
    <title>HSTS Preload List Submission</title>
    <author fullname="Anonymous">
      <organization></organization>
    </author>
  </front>
</reference>
</references>

<section anchor="acknowledgements"><name>Acknowledgements</name>
<t>This document was developed by the OpenID FAPI Working Group.</t>
<t>We would like to thank Takahiko Kawasaki, Filip Skokan, Nat Sakimura, Stuart Low, Dima Postnikov, Torsten Lodderstedt, Travis Spencer, Brian Campbell, Ralph Bragg, Łukasz Jaromin, Pedram Hosseyni, Ralf Küsters, Tim Würtele, Edmund Jay and Aaron Parecki for their valuable feedback and contributions that helped to evolve this document.</t>
</section>

<section anchor="notices"><name>Notices</name>
<t>Copyright (c) 2024 The OpenID Foundation.</t>
<t>The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.</t>
<t>The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required to practice this specification.</t>
</section>

<section anchor="document-history"><name>Document History</name>
<t>-04</t>

<ul spacing="compact">
<li>update draft version numbers</li>
<li>editorial changes for publication</li>
<li>clarification on audience requirements for private_key_jwt assertions</li>
</ul>
<t>-03</t>

<ul spacing="compact">
<li>Add more contributors</li>
<li>address key compromise issue</li>
<li>correct reference to RFC9068</li>
<li>add wording about stateful credentials</li>
<li>Add a note alerting readers to the fact bcp195 changes</li>
<li>update date of fapi2 security analysis</li>
<li>add reference to fapi2 security analysis</li>
<li>remove grant management and other non final specs</li>
<li>Refresh token rotation clarification</li>
<li>initial attempt at CORS wording</li>
<li>access token privilege restriction</li>
<li>client impersonation</li>
<li>add CORS reference</li>
<li>initial attempt at CORS wording</li>
<li>make client guidance wider than access tokens for least privilege clause</li>
<li>access token privilege restriction</li>
<li>Update Security BCP references</li>
<li>editorial: attempt to improve readability for clock skew clause</li>
<li>Remove expicit reference to ciphers</li>
<li>editorial content for the MTLS ecosystem section</li>
<li>don't preclude DPoP unintentionally</li>
<li>fix markdown syntax on one ietf-oauth-security-topics ref</li>
<li>fix section, title, etc</li>
<li>reworking the text around length of the state parameter</li>
<li>First draft for MTLS ecosystems</li>
<li>change this specification to this document - for ISO</li>
<li>increase EC key length requirement</li>
<li>add requirment for PKCE challenge</li>
<li>improve wording to remove shall be</li>
<li>make security considerations top level</li>
<li>add wording for state and nonce</li>
<li>Update clause reference in Note2, should refer to clause 10 instead of clause 9.</li>
<li>remove keyword can from note</li>
<li>Update clause reference in Note2, should refer to clause 10 instead of clause 9.</li>
<li>Update abbreviated terms</li>
<li>Make clearer why we don't need encrypted id tokens</li>
<li>fix spacing</li>
<li>remove keyword can from note</li>
<li>Make clearer why we don't need encrypted id tokens<br />
</li>
<li>allow future Ed25519 algorithm</li>
<li>Addresses #647 - Following documents are not normatively required</li>
<li>Add Joseph to the FAPI2 SP &amp; MS authors list</li>
<li>Fixes #661 - Move RAR to Bibliography</li>
<li>Fixes #661 - add FAPIMessageSigning to references</li>
<li>Fixes #661 - add FAPICIBA to references</li>
<li>Fixes #661 - add GM to references</li>
<li>Fixes #649 - ISO29100 and ISO29134 is not in the reference</li>
<li>Fixes #648 - The first paragraph of the Normative reference shall be as provided in ISODIR2</li>
<li>Fixes #643 - Subclause 5.3 has a hanging paragraph</li>
<li>Fixes #645 - Author name of Normative reference ISODIR2 is wrong</li>
<li>add text around enforcement of one-time use of require_uri</li>
<li><t>Fix capitalization</t>

<ul spacing="compact">
<li>Fixes #645 - Author name of Normative reference ISODIR2 is wrong</li>
</ul></li>
<li>Fixes #648 - The first paragraph of the Normative reference shall be as provided in ISODIR2</li>
<li>Fixes #643 - Subclause 5.3 has a hanging paragraph</li>
<li>Use consistent (ISO) list style and Fix Issue #668 (Capitalise compromising in 6.6.5), Fix Issue #667 (Fix spelling mistake in 5.6.2. (1))</li>
<li>Fix #644 (Notes need to be numbered)</li>
<li>Fix Issue #650 (5.3.2.1 bullet 5 missing a word or a comma?)</li>
<li>Fix Issue #654 (Replace [I-D.ietf-oauth-rar] with rfc9396)</li>
<li>Fix Issue #521 (NOTE in 5.2.1 has 'can')</li>
<li>Fix Issue #669 (Fix various spelling and grammatical mistakes)</li>
<li>Renumber attackers, fix editorial stuff</li>
<li>add text around enforcement of one-time use of require_uri</li>
<li>improve wording around which grant and response types are supported</li>
<li>editorial: make shall only consistent</li>
<li>add text about clock skew</li>
<li>Change references to RFC7525 to BCP195</li>
<li>editorial: make shall only consistent</li>
<li>make note around audience param clearer</li>
<li>Add text on conformance testing</li>
<li>add text about clock skew</li>
<li>move MTLS Protection of all endpoints to SP</li>
<li>adjust wording based on PR</li>
<li>adjust scope to make clear its not just clientS</li>
<li>Update DPoP references in FAPI 2 SP</li>
<li>fapi-2_0-security-profile.md edited online with Bitbucket</li>
<li>FAPI2: Change private_key_jwt aud requirements</li>
<li>request parameters via front channel clarification</li>
<li>Editorial fixes, working group in acknowledgements</li>
<li>Proposal to fix Issue #551</li>
<li>FAPI2SP: Fix some typos</li>
<li>increment version numbers</li>
</ul>
<t>-02</t>

<ul spacing="compact">
<li>update acknowledgements for FAPI 2</li>
<li>Update filenames</li>
<li>Fix some typos in Security Considerations</li>
<li>Fix typo in DPoP Proof Replay Security Considerations</li>
</ul>
<t>-01</t>

<ul spacing="compact">
<li>bump tls 1.2 cipher heading</li>
<li>update tls 1.2 cipher suites' section</li>
<li>use gender-neutral language</li>
<li>FAPI2SP: Add text about further profiling</li>
<li>Addressing issue #531 - Adding normative references clause in FAPI_2_0_Security_Profile.md</li>
<li>Reduced attacker model</li>
<li>FAPI2SP: Correct request_uri lifetime value in comparison table</li>
<li>FAPI2SP: Rework lower limit on request_uri expires_in</li>
<li>Update as per discussion on this week's call.</li>
<li>Add mentions of Authorization Code Binding to DPoP key</li>
<li>FAPI2SP: Add clause about access token lifetime</li>
<li>FAPI2SP: Limit authorization code lifetime</li>
<li>Proposal for ensuring security of issuer</li>
<li>Add security consideration for CSRF attack</li>
<li>Addressing issue #531 - Adding normative references clause in FAPI_2_0_Security_Profile.md</li>
<li>Improve comparison table</li>
<li>FAPI2SP: Add security consideration for cuckoo's token attack</li>
<li>FAPI2SP: Document DPoP proof leaks</li>
<li>Privacy considerations based on FAPI 1</li>
<li>FAPI2SP: Add requirement for RP to use discovery</li>
<li>Privacy considerations based on FAPI 1</li>
<li>Fix heading typo</li>
<li>Editorial: change AS to Authorization Server</li>
<li>Pull in key management clauses</li>
<li>Add text to deal with private_key_jwt clock skew</li>
<li>Add text to deal with private_key_jwt clock skew</li>
<li>Clarification around sender-constrained access token</li>
<li>Change name of FAPI security profile markdown file</li>
</ul>
</section>

</back>

</rfc>
